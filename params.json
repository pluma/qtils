{"name":"Qtils","tagline":"utilities for Q control flow.","body":"# Synopsis\r\n\r\n**qtils** is a utility library for [Q](https://github.com/kriskowal/q).\r\n\r\n[![Build Status](https://travis-ci.org/pluma/qtils.png?branch=master)](https://travis-ci.org/pluma/qtils) [![NPM version](https://badge.fury.io/js/qtils.png)](http://badge.fury.io/js/qtils) [![Dependencies](https://david-dm.org/pluma/qtils.png)](https://david-dm.org/pluma/qtils)\r\n\r\n# Note\r\n\r\nWhen dealing with multiple arguments in Q, it is customary to pass them around as arrays. Until EcmaScript 6 destructuring becomes widely available, this makes Q control flows with multiple promises a bit unpractical when you can't use `.spread`.\r\n\r\nIf you find yourself using `.spread` a lot but still want to give the array manipulation helpers in this library a try, consider using [spread-args](https://github.com/pluma/spread-args) to convert functions that take positional arguments into functions that accept a simple argument array.\r\n\r\n# Install\r\n\r\n## With NPM\r\n\r\n```sh\r\nnpm install qtils\r\n```\r\n\r\n## From source\r\n\r\n```sh\r\ngit clone https://github.com/pluma/qtils.git\r\ncd qtils\r\nnpm install\r\nmake test\r\n```\r\n\r\n# API\r\n\r\n## append(fn:Function):Function\r\n\r\nCreates a function that will pass its argument to the given function and returns a promise that will be resolved to the function's result appended to the argument.\r\n\r\nIf the argument is not an `Array`, it will be wrapped in one before the result is appended.\r\n\r\nExample:\r\n\r\n```javascript\r\nQ('foo')\r\n.then(qtils.append(function(str) {\r\n    return str.replace('f', 'b');\r\n}))\r\n.then(console.log); // ['foo', 'boo']\r\n```\r\n\r\n## prepend(fn:Function):Function\r\n\r\nCreates a function that will pass its argument to the given function and returns a promise that will be resolved to the function's result prepended to the argument.\r\n\r\nIf the argument is not an `Array`, it will be wrapped in one before the result is prepended.\r\n\r\nExample:\r\n\r\n```javascript\r\nQ('foo')\r\n.then(qtils.prepend(function(str) {\r\n    return str.replace('f', 'b');\r\n}))\r\n.then(console.log); // ['boo', 'foo']\r\n```\r\n\r\n## tee(fn:Function):Function\r\n\r\nCreates a function that will pass its argument to the given function and returns a promise that will be resolved to the argument when the function's result is fulfilled.\r\n\r\nIn other words, `tee` allows you to add `then`able side-effects to a promise chain (without having to modify them so they return their inputs).\r\n\r\nExample without `tee`:\r\n\r\n```javascript\r\nQ('foo')\r\n.then(function(str) {\r\n    console.log('Result is:', str); // 'Result is: \"foo\"'\r\n    return str; // Must return the input or next `then` will see `null`\r\n})\r\n.then(console.log); // 'foo'\r\n```\r\n\r\nExample with `tee`:\r\n\r\n```javascript\r\nQ('foo')\r\n.then(qtils.tee(function(str) {\r\n    console.log('Result is:', str); // 'Result is: \"foo\"'\r\n}))\r\n.then(console.log); // 'foo'\r\n```\r\n\r\n## eacharg(fns...):Function\r\n\r\nCreates a function that will pass each item in an array to each function and returns a promise that will be resolved to an array containing the results.\r\n\r\nIf the number of functions is smaller than the number of items in the array, it will loop over the functions.\r\n\r\nExample:\r\n\r\n```javascript\r\nQ(['Foo', 'Bar', 'Qux'])\r\n.then(qtils.eacharg(\r\n    function(str) {return str.toUpperCase();},\r\n    function(str) {return str.toLowerCase();}\r\n))\r\n.then(console.log); // ['FOO', 'bar', 'QUX']\r\n```\r\n\r\n## allargs(fns...):Function\r\n\r\nCreates a function that will pass its argument to each function and returns a promise that will be resolved to an array containing the results.\r\n\r\nExample:\r\n\r\n```javascript\r\nQ(['foo', 'bar', 'qux'])\r\n.then(qtils.allargs(\r\n    function(arr) {return arr.join('-');},\r\n    function(arr) {return arr.join('+');}\r\n))\r\n.then(console.log); // ['foo-bar-qux', 'foo+bar+qux']\r\n```\r\n\r\n## transform(props:Object, [keep:Boolean]):Function\r\n\r\nCreates a function that takes an object and will apply the given transformations to its properties and then returns a promise resolving to the result object.\r\n\r\nExample:\r\n\r\n```javascript\r\nvar person = {firstName: 'John', lastName: 'Doe'};\r\nQ(person)\r\n.then(qtils.transform({\r\n    lastName: function(str) {return str.toUpperCase();}\r\n}))\r\n.then(function(result) {\r\n    console.log(result); // {lastName: 'DOE'}\r\n    console.log(person); // {firstName: 'John', lastName: 'Doe'}\r\n});\r\n```\r\n\r\nIf `keep` is `true`, any properties that have no matching transformation will be copied to the result object verbatim. Otherwise they will be omitted.\r\n\r\nExample with `keep = true`:\r\n\r\n```javascript\r\nvar person = {firstName: 'John', lastName: 'Doe'};\r\nQ(person)\r\n.then(qtils.transform({\r\n    lastName: function(str) {return str.toUpperCase();}\r\n}, true))\r\n.then(function(result) {\r\n    console.log(result); // {firstName: 'John', lastName: 'DOE'}\r\n    console.log(person); // {firstName: 'John', lastName: 'Doe'}\r\n});\r\n```\r\n\r\n# License\r\n\r\nThe MIT/Expat license.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}